import java.net.ServerSocket;

/**
 * SensorConnThread
 * Process sensor manager's connection request and opening communication channel. (just like that with the client)
 * */
public class SensorConnThread extends Thread
{
	/**
	 * The sensor manager should use the same number.
	 * */
	int mServerPortNum = 9101;
	
	ServerSocket mAcceptSocket = null;
	
	SensorConnThread()
	{
		super();
		
		try{
			// Fixed port number.
			mAcceptSocket = new ServerSocket(mServerPortNum);
			
		}catch (Exception e){
			System.err.println("Exception creating ServerSocket");
		}
		
	}
	
	public void run() 
	{
		boolean bLoop = true;
		while(bLoop)
		{
			// Continuously waiting for a new client connection and generate a communication thread for each accepted client.
			
			System.out.println("Waiting for sensor manager connection at port " + mServerPortNum);

			try {
				// Will be blocked here..
				Socket ClientSocket = mAcceptSocket.accept();
				
				// Connected and create a new communication channel.
				Thread CliThreadObj = new ClientCommThread(ClientSocket);
				CliThreadObj.start();
			
				System.out.println("A client is connected @ " + ClientSocket.getLocalAddress() + ":" + ClientSocket.getLocalPort());
				
				// We probably need to manage all the connected client list, but not for this semester?
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}


/**
 * SensorCommThread
 * Communication to the sensor manager which contains all sensor's updated information,
 * being the port of getting the hardware information
 * */
class SensorCommThread extends Thread 
{
	SensorCommThread()
	{
		super();
	}

	
	public void run() 
	{
		// Initialize and do some communication to the sensor.

		long CachedPrevTickTime = System.currentTimeMillis();
		long TempExampleUpdateFrequency = 10000; // In millisec.
		
		boolean bLoop = true;
		while(bLoop)
		{		
			//////////////////////////////////////////////////////////////////////
			// Remove or modify this block when the real sensor communication is implemented here.
			
			long CurrTickTime = System.currentTimeMillis();
			
			// Use the abs value because I guess the currentTimeMillis might return reset value at some time..? 
			if( Math.abs(CurrTickTime - CachedPrevTickTime) > TempExampleUpdateFrequency )
			{
				boolean bNewState = !DataManager.GetSingleRestroomItemOccupied(ServerMain.EXAMPLE_RESTROOM_FLOORNUM, ServerMain.EXAMPLE_MALE_RESTROOM_ROOMNUM, 1); 
				// Just for an example, periodically switch the state.
				DataManager.SetSingleRestroomItemOccupied(ServerMain.EXAMPLE_RESTROOM_FLOORNUM, ServerMain.EXAMPLE_MALE_RESTROOM_ROOMNUM, 1, 
						bNewState);
				
				System.out.println("Restroom " + ServerMain.EXAMPLE_RESTROOM_FLOORNUM + " " +  ServerMain.EXAMPLE_MALE_RESTROOM_ROOMNUM
						+ " usage state changed to " + bNewState);
				
				CachedPrevTickTime = CurrTickTime;
			}
			
			//////////////////////////////////////////////////////////////////////
			
			
			
			// When you get the data from the sensor, set the data by calling DataManager.SetSingleRestroomItemOccupied();
			
		}
		
	}
}
