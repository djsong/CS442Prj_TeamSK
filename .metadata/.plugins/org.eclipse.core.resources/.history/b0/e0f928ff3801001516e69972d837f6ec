import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * SensorConnThread
 * Process connection request of the sensor manager and open communication channel. (just like that with the client)
 * */
public class SensorConnThread extends Thread
{
	/**
	 * The sensor manager should use the same number.
	 * */
	int mServerPortNum = 9101;
	
	ServerSocket mAcceptSocket = null;
	
	SensorConnThread()
	{
		super();
		
		try{
			// Fixed port number.
			mAcceptSocket = new ServerSocket(mServerPortNum);
			
		}catch (Exception e){
			System.err.println("Exception creating ServerSocket");
		}
	}
	
	public void run() 
	{
		boolean bLoop = true;
		while(bLoop)
		{
			// Continuously waiting for a new sensor manager connection and generate a communication thread for each accepted sensor manager (but actually just one?).
			
			System.out.println("Waiting for sensor manager connection at port " + mServerPortNum);

			try {
				// Will be blocked here..
				Socket SensorSocket = mAcceptSocket.accept();
				
				// Connected and create a new communication channel.
				Thread SensorThreadObj = new SensorCommThread(SensorSocket);
				SensorThreadObj.start();
			
				System.out.println("A sensor manager is connected @ " + SensorSocket.getLocalAddress() + ":" + SensorSocket.getLocalPort());
				
				// We probably need to manage all the connected client list, but not for this semester?
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}


/**
 * SensorCommThread
 * Communication to the sensor manager which contains all sensor's updated information,
 * being the port of getting the raw hardware information
 * */
class SensorCommThread extends Thread 
{
	Socket mCommSocket;

	/**
	 * In millisecond unit.
	 * Remove this variable and its relevant code if unnecessary due to the hardware conditions.
	 * */
	//final static long mDataReceivePeriod = 10;
	
	SensorCommThread(Socket InSocket)
	{
		super();
		
		this.mCommSocket = InSocket;
	}
	
	public void run() 
	{
		// Initialize and do some communication to the sensor.
		
		boolean bLoop = true;
		while(bLoop)
		{		
			// Just receive the information
			try {
				
				//long StartTickTime = System.currentTimeMillis();
				
				// Getting the packet in string format.
				BufferedReader SensorDataReader = new BufferedReader(new InputStreamReader(mCommSocket.getInputStream())); 
				String RecvString = SensorDataReader.readLine();
				
				ProcessPacketFromSensor(RecvString);
				
				
				// There are some problems with this receive period stuff. I guess this can be done only in sender's side?
				//long EndTickTime = System.currentTimeMillis();
				// Use the abs value because I guess the currentTimeMillis might return reset value at some time..?
				//long FrameDelta = Math.abs(EndTickTime - StartTickTime);
				//if(FrameDelta < mDataReceivePeriod)
				//{
                //	sleep(mDataReceivePeriod - FrameDelta);
                //}
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Parse the received packet and also update the internal data according to it.
	 * */
	private void ProcessPacketFromSensor(String InRecvString)
	{
		System.out.println("Received Packet : " + InRecvString);
		
		int ParsedFloorNum = 1;
		int ParsedRoomNum = 1;
		int ParsedItemNum = 1;
		boolean ParsedUsageState = false;
		
		
		// Try using StringTokenizer for parsing
		
		
		
		// For now, this just handles restroom, no other type of facility.
		
		// When you get the data from the sensor, set the data by calling DataManager.SetSingleRestroomItemOccupied();
		if( 
				DataManager.SetSingleRestroomItemOccupied(ParsedFloorNum, ParsedRoomNum, ParsedItemNum, ParsedUsageState) == true 
				)
		{
			System.out.println("Restroom " + ParsedFloorNum + " " +  ParsedRoomNum + " " + ParsedItemNum + " usage state changed to " + ParsedUsageState);		
		}
	}
}
